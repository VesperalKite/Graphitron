element Vertex end
element Edge end
const edges : edgeset{Edge}(Vertex, Vertex) = load(argv[1]);
const vertices : vertexset{Vertex} = edges.getVertices();
const cur_rank : vector{Vertex}(int);
const delta : vector{Vertex}(intx) = vertices.getProperty();
const out_degree : vector{Vertex}(int) = vertices.getOutDegrees();
const damp : double = 0.85;
const beta_score : int;
const x_score : int;
const epsilon : double = 0.1;
const round_id : int;

func float2int (x : double) -> y : int
    y = x * pow(2, 30);
end

func reset(v : Vertex) 
    cur_rank[v] = 0;
    delta[v] = float2int(1.0 / vertices.size());
end

func scatter(srcProp : intx)->update : intx
    update = srcProp;
end

func filter(update : intx) -> active : bool
    active = (update != -2147483647);
end

func gather(ori : intx, update : intx)->ngh_sum : intx
    ngh_sum = ori + update;
end

func v_update(ngh_sum : intx, srcProp : intx, v : Vertex)-> newProp : intx
    var tProp : intx;
    if (round_id == 1)
        tProp = damp*ngh_sum + beta_score;
        cur_rank[v] += tProp;
        tProp = tProp - x_score;
    else
        tProp = damp*ngh_sum;
        cur_rank[v] += tProp;
    end
    if (tProp < epsilon*cur_rank[v]) and (tProp > -epsilon*cur_rank[v]) 
        newProp = -2147483647;
    else
        newProp = tProp;
    end
end

func getBig() -> v : int
    var max : int = -2147483647;
    for i in 0:vertices.size()
        if (delta[i] > max)
            v = i;
            max = delta[i];
        end
    end
end

func main()
    vertices.init(reset);
    beta_score = float2int((1.0 - damp) / vertices.size());
    x_score = float2int(1.0 / vertices.size());
    edges.partition();
    var Bigv : int = 0;
    for it in 1:11
        round_id = it;
        startTimer();
        #s1# edges.iter(round_id).gs(scatter, filter, gather);
        vertices.apply(v_update);
        var exetime : double = stopTimer();
        delta.update();
        Bigv = getBig();
        print "The most important vertex is: ";
        println Bigv;
        print "elapsed time: ";
        println exetime;
    end
end
schedule:
    program->configSubpartitionPlan("s1", "estimator");